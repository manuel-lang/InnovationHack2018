{
  "_args": [
    [
      {
        "raw": "before-after-hook@^1.1.0",
        "scope": null,
        "escapedName": "before-after-hook",
        "name": "before-after-hook",
        "rawSpec": "^1.1.0",
        "spec": ">=1.1.0 <2.0.0",
        "type": "range"
      },
      "/Users/Manu/KIT/MicrosoftInnovationHack2018/node_modules/@octokit/rest"
    ]
  ],
  "_from": "before-after-hook@>=1.1.0 <2.0.0",
  "_id": "before-after-hook@1.1.0",
  "_inCache": true,
  "_location": "/before-after-hook",
  "_nodeVersion": "8.9.4",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/before-after-hook-1.1.0.tgz_1516086085421_0.30601541395299137"
  },
  "_npmUser": {
    "name": "gr2m",
    "email": "gregor@martynus.net"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "before-after-hook@^1.1.0",
    "scope": null,
    "escapedName": "before-after-hook",
    "name": "before-after-hook",
    "rawSpec": "^1.1.0",
    "spec": ">=1.1.0 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/@octokit/rest"
  ],
  "_resolved": "https://registry.npmjs.org/before-after-hook/-/before-after-hook-1.1.0.tgz",
  "_shasum": "83165e15a59460d13702cb8febd6a1807896db5a",
  "_shrinkwrap": null,
  "_spec": "before-after-hook@^1.1.0",
  "_where": "/Users/Manu/KIT/MicrosoftInnovationHack2018/node_modules/@octokit/rest",
  "author": {
    "name": "Gregor Martynus"
  },
  "bugs": {
    "url": "https://github.com/gr2m/before-after-hook/issues"
  },
  "dependencies": {},
  "description": "asynchronous before/error/after hooks for internal functionality",
  "devDependencies": {
    "browserify": "^15.0.0",
    "gaze-cli": "^0.2.0",
    "istanbul": "^0.4.0",
    "istanbul-coveralls": "^1.0.3",
    "mkdirp": "^0.5.1",
    "rimraf": "^2.4.4",
    "semantic-release": "^12.2.2",
    "simple-mock": "^0.8.0",
    "standard": "^10.0.0",
    "tap-min": "^1.0.0",
    "tap-spec": "^4.1.1",
    "tape": "^4.2.2",
    "uglify-js": "^3.0.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-VOMDtYPwLbIncTxNoSzRyvaMxtXmLWLUqr8k5AfC1BzLk34HvBXaQX8snOwQZ4c0aX8aSERqtJSiI9/m2u5kuA==",
    "shasum": "83165e15a59460d13702cb8febd6a1807896db5a",
    "tarball": "https://registry.npmjs.org/before-after-hook/-/before-after-hook-1.1.0.tgz"
  },
  "files": [
    "index.js",
    "lib"
  ],
  "gitHead": "9d76b1249baf2c31c668a77fe9b3d3020a601087",
  "homepage": "https://github.com/gr2m/before-after-hook#readme",
  "keywords": [
    "hook",
    "hooks",
    "api"
  ],
  "license": "Apache-2.0",
  "maintainers": [
    {
      "name": "gr2m",
      "email": "gregor@martynus.net"
    }
  ],
  "name": "before-after-hook",
  "optionalDependencies": {},
  "readme": "# before-after-hook\n\n> asynchronous before/error/after hooks for internal functionality\n\n[![Build Status](https://travis-ci.org/gr2m/before-after-hook.svg?branch=master)](https://travis-ci.org/gr2m/before-after-hook)\n[![Coverage Status](https://coveralls.io/repos/gr2m/before-after-hook/badge.svg?branch=master)](https://coveralls.io/r/gr2m/before-after-hook?branch=master)\n[![Greenkeeper badge](https://badges.greenkeeper.io/gr2m/before-after-hook.svg)](https://greenkeeper.io/)\n\n## Usage\n\n```js\n// instantiate hook API\nconst hook = new Hook()\n\n// Create a hook\nhook('get', getData)\n  .then(handleData)\n  .catch(handleGetError)\n\n// register before/after/error hooks.\n// The methods can be asynchronous by returning a Promise\nhook.before('get', beforeHook)\nhook.error('get', errorHook)\nhook.after('get', afterHook)\n```\n\nThe methods are executed in the following order\n\n1. `beforeHook`\n2. `getData`\n3. `afterHook`\n4. `handleData`\n\nIf an error is thrown in `beforeHook` or `getData` then `errorHook` is\ncalled next.\n\nIf `afterHook` throws an error then `handleGetError` is called instead\nof `handleData`.\n\nIf `errorHook` throws an error then `handleGetError` is called next, otherwise\n`afterHook` and `handleData`.\n\n## Install\n\n```\nnpm install before-after-hook\n```\n\nOr download [the latest `before-after-hook.min.js`](https://github.com/gr2m/before-after-hook/releases/latest).\n\n## API\n\n- [Constructor](#constructor)\n- [hook.api](#hookapi)\n- [hook()](#hook)\n- [hook.before()](#hookbefore)\n- [hook.error()](#hookerror)\n- [hook.after()](#hookafter)\n- [hook.remove.before()](#hookremovebefore)\n- [hook.remove.error()](#hookremoveerror)\n- [hook.remove.after()](#hookremoveafter)\n\n### Constructor\n\nThe `Hook` constructor has no options and returns a `hook` instance with the\nmethods below\n\n```js\nconst hook = new Hook()\n```\n\n### hook.api\n\nUse the `api` property to return the public API:\n\n- [hook.before()](#hookbefore)\n- [hook.after()](#hookafter)\n- [hook.error()](#hookafter)\n- [hook.remove.before()](#hookremovebefore)\n- [hook.remove.after()](#hookremoveafter)\n- [hook.remove.error()](#hookremoveerror)\n\nThat way you don’t need to expose the [hook()](#hook) method to consumers of your library\n\n### hook()\n\nInvoke before and after hooks. Returns a promise.\n\n```js\nhook(nameOrNames, [options,] method)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String or Array of Strings</td>\n    <td>Hook name, for example <code>'save'</code>. Or an array of names, see example below.</td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>options</code></th>\n    <td>Object</td>\n    <td>Will be passed to all before hooks as reference, so they can mutate it</td>\n    <td>No, defaults to empty object (<code>{}</code>)</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>method</code></th>\n    <td>Function</td>\n    <td>Callback to be executed after all before hooks finished execution successfully. <code>options</code> is passed as first argument</td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nResolves with whatever `method` returns or resolves with.\nRejects with error that is thrown or rejected with by\n\n1. Any of the before hooks, whichever rejects / throws first\n2. `method`\n3. Any of the after hooks, whichever rejects / throws first\n\nSimple Example\n\n```js\nhook('save', record, function (record) {\n  return store.save(record)\n})\n// shorter:  hook('save', record, store.save)\n\nhook.before('save', function addTimestamps (record) {\n  const now = new Date().toISOString()\n  if (record.createdAt) {\n    record.updatedAt = now\n  } else {\n    record.createdAt = now\n  }\n})\n```\n\nExample defining multiple hooks at once.\n\n```js\nhook(['add', 'save'], record, function (record) {\n  return store.save(record)\n})\n\nhook.before('add', function addTimestamps (record) {\n  if (!record.type) {\n    throw new Error('type property is required')\n  }\n})\n\nhook.before('save', function addTimestamps (record) {\n  if (!record.type) {\n    throw new Error('type property is required')\n  }\n})\n```\n\nDefining multiple hooks is helpful if you have similar methods for which you want to define separate hooks, but also an additional hook that gets called for all at once. The example above is equal to this:\n\n```js\nhook('add', record, function (record) {\n  return hook('save', record, function (record) {\n    return store.save(record)\n  })\n})\n```\n\n### hook.before()\n\nAdd before hook for given name. Returns `hook` instance for chaining.\n\n```js\nhook.before(name, method)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String</td>\n    <td>Hook name, for example <code>'save'</code></td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>method</code></th>\n    <td>Function</td>\n    <td>\n      Executed before the wrapped method. Called with the hook’s\n      <code>options</code> argument. Before hooks can mutate the passed options\n      before they are passed to the wrapped method.\n    </td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nExample\n\n```js\nhook.before('save', function validate (record) {\n  if (!record.name) {\n    throw new Error('name property is required')\n  }\n})\n```\n\n### hook.error()\n\nAdd error hook for given name. Returns `hook` instance for chaining.\n\n```js\nhook.error(name, method)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String</td>\n    <td>Hook name, for example <code>'save'</code></td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>method</code></th>\n    <td>Function</td>\n    <td>\n      Executed when an error occurred in either the wrapped method or a\n      <code>before</code> hook. Called with the thrown <code>error</code>\n      and the hook’s <code>options</code> argument. The first <code>method</code>\n      which does not throw an error will set the result that the after hook\n      methods will receive.\n    </td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nExample\n\n```js\nhook.error('save', function (error, options) {\n  if (error.ignore) return\n  throw error\n})\n```\n\n### hook.after()\n\nAdd after hook for given name. Returns `hook` instance for chaining.\n\n```js\nhook.after(name, method)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String</td>\n    <td>Hook name, for example <code>'save'</code></td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>method</code></th>\n    <td>Function</td>\n    <td>\n      Executed after wrapped method. Called with what the wrapped method\n      resolves with the hook’s <code>options</code> argument.\n    </td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nExample\n\n```js\nhook.after('save', function (result, options) {\n  if (result.updatedAt) {\n    app.emit('update', result)\n  } else {\n    app.emit('create', result)\n  }\n})\n```\n\n### hook.remove.before()\n\nRemoves before hook for given name. Returns `hook` instance for chaining.\n\n```js\nhook.remove.before(name, beforeHookMethod)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String</td>\n    <td>Hook name, for example <code>'save'</code></td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>beforeHookMethod</code></th>\n    <td>Function</td>\n    <td>\n      Same function that was previously passed to <code>hook.before()</code>\n    </td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nExample\n\n```js\nhook.remove.before('save', validateRecord)\n```\n\n### hook.remove.error()\n\nRemoves error hook for given name. Returns `hook` instance for chaining.\n\n```js\nhook.remove.error(name, afterHookMethod)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String</td>\n    <td>Hook name, for example <code>'save'</code></td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>afterHookMethod</code></th>\n    <td>Function</td>\n    <td>\n      Same function that was previously passed to <code>hook.error()</code>\n    </td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nExample\n\n```js\nhook.remove.error('save', handleError)\n```\n\n### hook.remove.after()\n\nRemoves after hook for given name. Returns `hook` instance for chaining.\n\n```js\nhook.remove.after(name, afterHookMethod)\n```\n\n<table>\n  <thead>\n    <tr>\n      <th>Argument</th>\n      <th>Type</th>\n      <th>Description</th>\n      <th>Required</th>\n    </tr>\n  </thead>\n  <tr>\n    <th align=\"left\"><code>name</code></th>\n    <td>String</td>\n    <td>Hook name, for example <code>'save'</code></td>\n    <td>Yes</td>\n  </tr>\n  <tr>\n    <th align=\"left\"><code>afterHookMethod</code></th>\n    <td>Function</td>\n    <td>\n      Same function that was previously passed to <code>hook.after()</code>\n    </td>\n    <td>Yes</td>\n  </tr>\n</table>\n\nExample\n\n```js\nhook.remove.after('save', triggerEvents)\n```\n\n## See also\n\nIf `before-after-hook` is not for you, have a look at one of these alternatives:\n\n- https://github.com/keystonejs/grappling-hook\n- https://github.com/sebelga/promised-hooks\n- https://github.com/bnoguchi/hooks-js\n- https://github.com/cb1kenobi/hook-emitter\n\n## License\n\n[Apache 2.0](LICENSE)\n",
  "readmeFilename": "README.md",
  "release": {
    "publish": [
      "@semantic-release/npm",
      {
        "path": "@semantic-release/github",
        "assets": [
          "dist/*.js"
        ]
      }
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gr2m/before-after-hook.git"
  },
  "scripts": {
    "build": "browserify index.js --standalone=Hook > dist/before-after-hook.js",
    "postbuild": "uglifyjs dist/before-after-hook.js -mc > dist/before-after-hook.min.js",
    "prebuild": "rimraf dist && mkdirp dist",
    "presemantic-release": "npm run build",
    "pretest": "standard",
    "semantic-release": "semantic-release",
    "test": "npm run -s test:node | tap-spec",
    "test:coverage": "istanbul cover test",
    "test:coverage:upload": "istanbul-coveralls",
    "test:node": "node test",
    "test:watch": "gaze 'clear && node test | tap-min' 'test/**/*.js' 'index.js' 'lib/**/*.js'"
  },
  "version": "1.1.0"
}
